/* tslint:disable */
/* eslint-disable */
/**
 * ShipStation API v2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { BatchStatus } from '../models';
// @ts-ignore
import type { BatchesSortBy } from '../models';
// @ts-ignore
import type { CreateAndProcessBatchRequestBody } from '../models';
// @ts-ignore
import type { CreateBatchRequest } from '../models';
// @ts-ignore
import type { CreateBatchResponseBody } from '../models';
// @ts-ignore
import type { ErrorResponseBody } from '../models';
// @ts-ignore
import type { GetBatchByExternalIdResponseBody } from '../models';
// @ts-ignore
import type { GetBatchByIdResponseBody } from '../models';
// @ts-ignore
import type { ListBatchErrorsResponseBody } from '../models';
// @ts-ignore
import type { ListBatchesResponseBody } from '../models';
// @ts-ignore
import type { ProcessBatchRequestBody } from '../models';
// @ts-ignore
import type { RemoveFromBatchRequestBody } from '../models';
// @ts-ignore
import type { SortDir } from '../models';
/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a shipment or rate to a batch.
         * @summary Add to a batch
         * @param {string} batchId Batch ID
         * @param {CreateAndProcessBatchRequestBody} createAndProcessBatchRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBatch: async (batchId: string, createAndProcessBatchRequestBody: CreateAndProcessBatchRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('addToBatch', 'batchId', batchId)
            // verify required parameter 'createAndProcessBatchRequestBody' is not null or undefined
            assertParamExists('addToBatch', 'createAndProcessBatchRequestBody', createAndProcessBatchRequestBody)
            const localVarPath = `/v2/batches/{batch_id}/add`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAndProcessBatchRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch containing multiple labels.
         * @summary Create a batch
         * @param {CreateBatchRequest} createBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch: async (createBatchRequest: CreateBatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBatchRequest' is not null or undefined
            assertParamExists('createBatch', 'createBatchRequest', createBatchRequest)
            const localVarPath = `/v2/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a batch based on its batch id. Sets its status to \'archived\'.
         * @summary Delete batch by id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('deleteBatch', 'batchId', batchId)
            const localVarPath = `/v2/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retreive a batch using an external batch ID
         * @summary Get batch by external id
         * @param {string} externalBatchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchByExternalId: async (externalBatchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalBatchId' is not null or undefined
            assertParamExists('getBatchByExternalId', 'externalBatchId', externalBatchId)
            const localVarPath = `/v2/batches/external_batch_id/{external_batch_id}`
                .replace(`{${"external_batch_id"}}`, encodeURIComponent(String(externalBatchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get batch details for a specific batch id.
         * @summary Get batch by id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchById: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchById', 'batchId', batchId)
            const localVarPath = `/v2/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Errors in batches must be handled differently from synchronous requests. You must retrieve the status of your batch by getting a batch and getting an overview of the statuses or by listing the batch errors. 
         * @summary Get batch errors
         * @param {string} batchId Batch ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned. 
         * @param {number} [pagesize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchErrors: async (batchId: string, page?: number, pagesize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('listBatchErrors', 'batchId', batchId)
            const localVarPath = `/v2/batches/{batch_id}/errors`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the batches associated with your ShipStation account.
         * @summary List batches
         * @param {BatchStatus} [status] 
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned. 
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {string} [batchNumber] Batch Number
         * @param {BatchesSortBy} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches: async (status?: BatchStatus, page?: number, pageSize?: number, sortDir?: SortDir, batchNumber?: string, sortBy?: BatchesSortBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (batchNumber !== undefined) {
                localVarQueryParameter['batch_number'] = batchNumber;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create and purchase the labels for the shipments included in the batch.
         * @summary Process batch id labels
         * @param {string} batchId Batch ID
         * @param {ProcessBatchRequestBody} processBatchRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processBatch: async (batchId: string, processBatchRequestBody: ProcessBatchRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('processBatch', 'batchId', batchId)
            // verify required parameter 'processBatchRequestBody' is not null or undefined
            assertParamExists('processBatch', 'processBatchRequestBody', processBatchRequestBody)
            const localVarPath = `/v2/batches/{batch_id}/process/labels`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processBatchRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove specific shipment ids or rate ids from a batch.
         * @summary Remove from batch
         * @param {string} batchId Batch ID
         * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromBatch: async (batchId: string, removeFromBatchRequestBody: RemoveFromBatchRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('removeFromBatch', 'batchId', batchId)
            // verify required parameter 'removeFromBatchRequestBody' is not null or undefined
            assertParamExists('removeFromBatch', 'removeFromBatchRequestBody', removeFromBatchRequestBody)
            const localVarPath = `/v2/batches/{batch_id}/remove`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeFromBatchRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a batch by id setting its status to \'archived\'.
         * @summary Update batch status to \'archived\' by id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('updateBatch', 'batchId', batchId)
            const localVarPath = `/v2/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_keys required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a shipment or rate to a batch.
         * @summary Add to a batch
         * @param {string} batchId Batch ID
         * @param {CreateAndProcessBatchRequestBody} createAndProcessBatchRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToBatch(batchId: string, createAndProcessBatchRequestBody: CreateAndProcessBatchRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addToBatch(batchId, createAndProcessBatchRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.addToBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a batch containing multiple labels.
         * @summary Create a batch
         * @param {CreateBatchRequest} createBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatch(createBatchRequest: CreateBatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBatchResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatch(createBatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.createBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a batch based on its batch id. Sets its status to \'archived\'.
         * @summary Delete batch by id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBatch(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatch(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.deleteBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retreive a batch using an external batch ID
         * @summary Get batch by external id
         * @param {string} externalBatchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchByExternalId(externalBatchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBatchByExternalIdResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchByExternalId(externalBatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.getBatchByExternalId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get batch details for a specific batch id.
         * @summary Get batch by id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchById(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBatchByIdResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchById(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.getBatchById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Errors in batches must be handled differently from synchronous requests. You must retrieve the status of your batch by getting a batch and getting an overview of the statuses or by listing the batch errors. 
         * @summary Get batch errors
         * @param {string} batchId Batch ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned. 
         * @param {number} [pagesize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchErrors(batchId: string, page?: number, pagesize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchErrorsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchErrors(batchId, page, pagesize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.listBatchErrors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the batches associated with your ShipStation account.
         * @summary List batches
         * @param {BatchStatus} [status] 
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned. 
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {string} [batchNumber] Batch Number
         * @param {BatchesSortBy} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatches(status?: BatchStatus, page?: number, pageSize?: number, sortDir?: SortDir, batchNumber?: string, sortBy?: BatchesSortBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchesResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.listBatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create and purchase the labels for the shipments included in the batch.
         * @summary Process batch id labels
         * @param {string} batchId Batch ID
         * @param {ProcessBatchRequestBody} processBatchRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processBatch(batchId: string, processBatchRequestBody: ProcessBatchRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processBatch(batchId, processBatchRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.processBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove specific shipment ids or rate ids from a batch.
         * @summary Remove from batch
         * @param {string} batchId Batch ID
         * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromBatch(batchId: string, removeFromBatchRequestBody: RemoveFromBatchRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFromBatch(batchId, removeFromBatchRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.removeFromBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a batch by id setting its status to \'archived\'.
         * @summary Update batch status to \'archived\' by id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatch(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatch(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.updateBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Add a shipment or rate to a batch.
         * @summary Add to a batch
         * @param {string} batchId Batch ID
         * @param {CreateAndProcessBatchRequestBody} createAndProcessBatchRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBatch(batchId: string, createAndProcessBatchRequestBody: CreateAndProcessBatchRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.addToBatch(batchId, createAndProcessBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a batch containing multiple labels.
         * @summary Create a batch
         * @param {CreateBatchRequest} createBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(createBatchRequest: CreateBatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateBatchResponseBody> {
            return localVarFp.createBatch(createBatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a batch based on its batch id. Sets its status to \'archived\'.
         * @summary Delete batch by id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteBatch(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retreive a batch using an external batch ID
         * @summary Get batch by external id
         * @param {string} externalBatchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchByExternalId(externalBatchId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBatchByExternalIdResponseBody> {
            return localVarFp.getBatchByExternalId(externalBatchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get batch details for a specific batch id.
         * @summary Get batch by id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchById(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBatchByIdResponseBody> {
            return localVarFp.getBatchById(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Errors in batches must be handled differently from synchronous requests. You must retrieve the status of your batch by getting a batch and getting an overview of the statuses or by listing the batch errors. 
         * @summary Get batch errors
         * @param {string} batchId Batch ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned. 
         * @param {number} [pagesize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchErrors(batchId: string, page?: number, pagesize?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListBatchErrorsResponseBody> {
            return localVarFp.listBatchErrors(batchId, page, pagesize, options).then((request) => request(axios, basePath));
        },
        /**
         * List the batches associated with your ShipStation account.
         * @summary List batches
         * @param {BatchStatus} [status] 
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned. 
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {string} [batchNumber] Batch Number
         * @param {BatchesSortBy} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(status?: BatchStatus, page?: number, pageSize?: number, sortDir?: SortDir, batchNumber?: string, sortBy?: BatchesSortBy, options?: RawAxiosRequestConfig): AxiosPromise<ListBatchesResponseBody> {
            return localVarFp.listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Create and purchase the labels for the shipments included in the batch.
         * @summary Process batch id labels
         * @param {string} batchId Batch ID
         * @param {ProcessBatchRequestBody} processBatchRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processBatch(batchId: string, processBatchRequestBody: ProcessBatchRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.processBatch(batchId, processBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove specific shipment ids or rate ids from a batch.
         * @summary Remove from batch
         * @param {string} batchId Batch ID
         * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromBatch(batchId: string, removeFromBatchRequestBody: RemoveFromBatchRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.removeFromBatch(batchId, removeFromBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a batch by id setting its status to \'archived\'.
         * @summary Update batch status to \'archived\' by id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.updateBatch(batchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Add a shipment or rate to a batch.
     * @summary Add to a batch
     * @param {string} batchId Batch ID
     * @param {CreateAndProcessBatchRequestBody} createAndProcessBatchRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public addToBatch(batchId: string, createAndProcessBatchRequestBody: CreateAndProcessBatchRequestBody, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).addToBatch(batchId, createAndProcessBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a batch containing multiple labels.
     * @summary Create a batch
     * @param {CreateBatchRequest} createBatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createBatch(createBatchRequest: CreateBatchRequest, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createBatch(createBatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a batch based on its batch id. Sets its status to \'archived\'.
     * @summary Delete batch by id
     * @param {string} batchId Batch ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public deleteBatch(batchId: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).deleteBatch(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retreive a batch using an external batch ID
     * @summary Get batch by external id
     * @param {string} externalBatchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatchByExternalId(externalBatchId: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatchByExternalId(externalBatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get batch details for a specific batch id.
     * @summary Get batch by id
     * @param {string} batchId Batch ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatchById(batchId: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatchById(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Errors in batches must be handled differently from synchronous requests. You must retrieve the status of your batch by getting a batch and getting an overview of the statuses or by listing the batch errors. 
     * @summary Get batch errors
     * @param {string} batchId Batch ID
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned. 
     * @param {number} [pagesize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchErrors(batchId: string, page?: number, pagesize?: number, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchErrors(batchId, page, pagesize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the batches associated with your ShipStation account.
     * @summary List batches
     * @param {BatchStatus} [status] 
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned. 
     * @param {number} [pageSize] The number of results to return per response.
     * @param {SortDir} [sortDir] Controls the sort order of the query.
     * @param {string} [batchNumber] Batch Number
     * @param {BatchesSortBy} [sortBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatches(status?: BatchStatus, page?: number, pageSize?: number, sortDir?: SortDir, batchNumber?: string, sortBy?: BatchesSortBy, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create and purchase the labels for the shipments included in the batch.
     * @summary Process batch id labels
     * @param {string} batchId Batch ID
     * @param {ProcessBatchRequestBody} processBatchRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public processBatch(batchId: string, processBatchRequestBody: ProcessBatchRequestBody, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).processBatch(batchId, processBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove specific shipment ids or rate ids from a batch.
     * @summary Remove from batch
     * @param {string} batchId Batch ID
     * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public removeFromBatch(batchId: string, removeFromBatchRequestBody: RemoveFromBatchRequestBody, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).removeFromBatch(batchId, removeFromBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a batch by id setting its status to \'archived\'.
     * @summary Update batch status to \'archived\' by id
     * @param {string} batchId Batch ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public updateBatch(batchId: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).updateBatch(batchId, options).then((request) => request(this.axios, this.basePath));
    }
}

